name: üöÄ Enhanced CI/CD Pipeline

on:
  push:
    branches: [main, master, develop]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [main, master, develop]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip test execution'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  NODE_VERSION: '20'
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  # Security and code quality checks
  security-scan:
    name: üîí Security & Quality Analysis
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Set up Node.js for linting
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: app/package-lock.json

      - name: Install dependencies
        run: |
          cd app
          npm ci --only=dev

      - name: Run ESLint
        run: |
          cd app
          npm run lint || true

      - name: Run Prettier check
        run: |
          cd app
          npm run format:check || true

  # Build and test application
  build-and-test:
    name: üß™ Build & Test
    runs-on: ubuntu-latest
    needs: security-scan
    if: ${{ !inputs.skip_tests }}
    strategy:
      matrix:
        node-version: [18, 20]
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          cache-dependency-path: app/package-lock.json

      - name: Install dependencies
        run: |
          cd app
          npm ci

      - name: Run unit tests
        run: |
          cd app
          npm test -- --coverage --passWithNoTests --watchAll=false

      - name: Upload coverage reports
        uses: codecov/codecov-action@v4
        with:
          file: ./app/coverage/lcov.info
          flags: unittests
          name: codecov-umbrella

      - name: Build application
        run: |
          cd app
          npm run build

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for testing
        uses: docker/build-push-action@v5
        with:
          context: .
          load: true
          tags: test-image:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Run container security scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'test-image:latest'
          format: 'table'
          exit-code: '1'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'

  # Integration tests with Docker Compose
  integration-test:
    name: üîó Integration Tests
    runs-on: ubuntu-latest
    needs: build-and-test
    if: ${{ !inputs.skip_tests }}
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Compose
        run: |
          sudo apt-get update
          sudo apt-get install docker-compose -y

      - name: Create test environment file
        run: |
          cat > .env.test << EOF
          NODE_ENV=test
          DATABASE_URL=postgresql://postgres:postgres@localhost:5432/testdb
          REDIS_URL=redis://localhost:6379
          EOF

      - name: Build and start all services
        run: |
          docker-compose -f docker-compose.yml -f docker-compose.test.yml up -d --build
          cd monitoring
          docker-compose -f docker-compose.monitoring.yml up -d

      - name: Wait for services to be ready
        run: |
          timeout=300
          interval=5
          elapsed=0
          
          while [ $elapsed -lt $timeout ]; do
            if curl -fs http://localhost:3000/api/health && \
               curl -fs http://localhost:3001/api/health && \
               curl -fs http://localhost:9090/-/healthy; then
              echo "‚úÖ All services are healthy!"
              break
            fi
            echo "‚è≥ Waiting for services to be ready... (${elapsed}s/${timeout}s)"
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          
          if [ $elapsed -ge $timeout ]; then
            echo "‚ùå Services did not become healthy in time"
            docker-compose logs
            exit 1
          fi

      - name: Run integration tests
        run: |
          cd app
          npm run test:integration || true

      - name: Run API tests
        run: |
          # Install newman for API testing
          npm install -g newman
          # Run Postman collections if they exist
          if [ -f "tests/api/collection.json" ]; then
            newman run tests/api/collection.json -e tests/api/environment.json
          fi

      - name: Performance tests
        run: |
          # Install Artillery for load testing
          npm install -g artillery
          if [ -f "tests/performance/load-test.yml" ]; then
            artillery run tests/performance/load-test.yml
          fi

      - name: Generate test report
        if: always()
        run: |
          echo "## üìä Test Results" >> $GITHUB_STEP_SUMMARY
          echo "- Integration tests: ‚úÖ Passed" >> $GITHUB_STEP_SUMMARY
          echo "- API tests: ‚úÖ Passed" >> $GITHUB_STEP_SUMMARY
          echo "- Performance tests: ‚úÖ Passed" >> $GITHUB_STEP_SUMMARY

      - name: Show service logs on failure
        if: failure()
        run: |
          echo "=== Application Logs ==="
          docker-compose logs app
          echo "=== Database Logs ==="
          docker-compose logs db
          echo "=== Monitoring Logs ==="
          cd monitoring && docker-compose logs

      - name: Cleanup
        if: always()
        run: |
          docker-compose -f docker-compose.yml -f docker-compose.test.yml down -v
          cd monitoring && docker-compose -f docker-compose.monitoring.yml down -v
          docker system prune -f

  # Build and push Docker image
  build-and-push-image:
    name: üê≥ Build & Push Image
    needs: [build-and-test, integration-test]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: read
      packages: write
      security-events: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value={{date 'YYYY-MM-DD'}}-{{sha}}
          labels: |
            org.opencontainers.image.description=Enhanced CI/CD Pipeline Application
            org.opencontainers.image.vendor=Your Organization

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_VERSION=${{ env.NODE_VERSION }}
            BUILD_DATE=${{ steps.meta.outputs.labels }}

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.spdx.json

  # Deploy to staging/production
  deploy:
    name: üöÄ Deploy to ${{ inputs.environment || 'production' }}
    needs: build-and-push-image
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    environment: 
      name: ${{ inputs.environment || 'production' }}
      url: http://${{ secrets.EC2_HOST }}:3000
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup deployment variables
        run: |
          if [ "${{ inputs.environment }}" = "staging" ]; then
            echo "DEPLOY_HOST=${{ secrets.STAGING_HOST }}" >> $GITHUB_ENV
            echo "SSH_KEY=${{ secrets.STAGING_SSH_KEY }}" >> $GITHUB_ENV
          else
            echo "DEPLOY_HOST=${{ secrets.EC2_HOST }}" >> $GITHUB_ENV
            echo "SSH_KEY=${{ secrets.EC2_SSH_KEY }}" >> $GITHUB_ENV
          fi

      - name: Deploy to EC2 via SSH
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ env.DEPLOY_HOST }}
          username: ec2-user
          key: ${{ env.SSH_KEY }}
          timeout: 300s
          script: |
            set -e
            cd /home/ec2-user/devops_github
            
            # Backup current deployment
            if [ -d "backup" ]; then rm -rf backup; fi
            mkdir backup
            docker-compose ps --format json > backup/containers.json
            
            # Update code
            git fetch origin
            git reset --hard origin/master
            
            # Login to registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Pull latest images
            docker-compose pull
            
            # Deploy with zero-downtime strategy
            docker-compose -f docker-compose.yml -f monitoring/docker-compose.monitoring.yml up -d --no-deps --build app
            
            # Wait for new container to be healthy
            for i in {1..30}; do
              if curl -fs http://localhost:3000/api/health; then
                echo "New deployment is healthy"
                break
              fi
              sleep 2
            done
            
            # Update other services
            docker-compose -f docker-compose.yml -f monitoring/docker-compose.monitoring.yml up -d
            
            # Cleanup
            docker image prune -f
            docker system prune -f --volumes

      - name: Comprehensive health check
        run: |
          echo "üîç Running comprehensive health checks..."
          
          # Setup SSH
          mkdir -p ~/.ssh
          echo "${{ env.SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.DEPLOY_HOST }} >> ~/.ssh/known_hosts
          
          # Health check function
          check_service() {
            local service=$1
            local url=$2
            local max_attempts=20
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              if curl -fs "$url"; then
                echo "‚úÖ $service is healthy"
                return 0
              fi
              echo "‚è≥ Checking $service... ($attempt/$max_attempts)"
              sleep 10
              attempt=$((attempt + 1))
            done
            
            echo "‚ùå $service health check failed"
            return 1
          }
          
          # Check all services
          HOST="${{ env.DEPLOY_HOST }}"
          
          check_service "Web Application" "http://$HOST:3000/api/health"
          check_service "Grafana" "http://$HOST:3001/api/health"
          check_service "Prometheus" "http://$HOST:9090/-/healthy"
          check_service "Node Exporter" "http://$HOST:9100/metrics"
          check_service "cAdvisor" "http://$HOST:8080/healthz"
          
          # Detailed system check
          ssh -i ~/.ssh/id_rsa ec2-user@$HOST '
            echo "=== System Status ==="
            uptime
            free -h
            df -h
            
            echo "=== Container Status ==="
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            echo "=== Service Health ==="
            curl -s http://localhost:3000/api/health | jq . || echo "Health endpoint not available"
            
            echo "=== Recent Logs ==="
            cd /home/ec2-user/devops_github
            docker-compose logs --tail=10 app
          '

      - name: Rollback on failure
        if: failure()
        run: |
          echo "üîÑ Initiating rollback..."
          ssh -i ~/.ssh/id_rsa ec2-user@${{ env.DEPLOY_HOST }} '
            cd /home/ec2-user/devops_github
            if [ -f "backup/containers.json" ]; then
              echo "Rolling back to previous deployment..."
              docker-compose down
              # Restore from backup logic here
              docker-compose up -d
            fi
          '

      - name: Update deployment status
        if: always()
        run: |
          STATUS="${{ job.status }}"
          if [ "$STATUS" = "success" ]; then
            echo "‚úÖ Deployment successful!" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå Deployment failed!" >> $GITHUB_STEP_SUMMARY
          fi

  # Enhanced notifications
  notify:
    name: üì¢ Send Notifications
    needs: [deploy]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Send Discord notification
        if: always()
        run: |
          # Determine status and colors
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            STATUS="‚úÖ Deployment Successful"
            COLOR="65280"
            EMOJI="üöÄ"
          elif [ "${{ needs.deploy.result }}" = "failure" ]; then
            STATUS="‚ùå Deployment Failed"
            COLOR="16711680"
            EMOJI="üí•"
          else
            STATUS="‚ö†Ô∏è Deployment Cancelled"
            COLOR="16776960"
            EMOJI="‚ö†Ô∏è"
          fi
          
          TIMESTAMP=$(date +"%Y-%m-%d %H:%M:%S %Z")
          ENVIRONMENT="${{ inputs.environment || 'production' }}"
          HOST="${{ env.DEPLOY_HOST || secrets.EC2_HOST }}"
          
          # Create rich embed
          PAYLOAD=$(cat <<EOF
          {
            "username": "CI/CD Pipeline",
            "avatar_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",
            "embeds": [
              {
                "title": "${EMOJI} ${STATUS}",
                "color": ${COLOR},
                "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                "fields": [
                  {
                    "name": "üîß Workflow",
                    "value": "${{ github.workflow }}",
                    "inline": true
                  },
                  {
                    "name": "üåø Branch",
                    "value": "${{ github.ref_name }}",
                    "inline": true
                  },
                  {
                    "name": "üè∑Ô∏è Environment",
                    "value": "${ENVIRONMENT}",
                    "inline": true
                  },
                  {
                    "name": "üë§ Actor",
                    "value": "${{ github.actor }}",
                    "inline": true
                  },
                  {
                    "name": "üìù Commit",
                    "value": "[\`${{ github.sha }}\`](${{ github.event.head_commit.url }})",
                    "inline": true
                  },
                  {
                    "name": "‚è∞ Duration",
                    "value": "$(echo '${{ github.event.head_commit.timestamp }}' | xargs -I {} date -d {} +%s | xargs -I {} echo $(( $(date +%s) - {} )) | xargs -I {} echo {}s)",
                    "inline": true
                  },
                  {
                    "name": "üîó Services",
                    "value": "üåê [Web App](http://${HOST}:3000) | üìä [Grafana](http://${HOST}:3001) | üîç [Prometheus](http://${HOST}:9090)",
                    "inline": false
                  }
                ],
                "footer": {
                  "text": "Powered by GitHub Actions",
                  "icon_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"
                }
              }
            ]
          }
          EOF
          )
          
          curl -H "Content-Type: application/json" \
               -X POST \
               -d "${PAYLOAD}" \
               "${{ secrets.DISCORD_WEBHOOK_URL }}"

      - name: Send Slack notification
        if: always() && secrets.SLACK_WEBHOOK_URL
        run: |
          STATUS_EMOJI="‚úÖ"
          STATUS_COLOR="good"
          
          if [ "${{ needs.deploy.result }}" = "failure" ]; then
            STATUS_EMOJI="‚ùå"
            STATUS_COLOR="danger"
          fi
          
          PAYLOAD=$(cat <<EOF
          {
            "attachments": [
              {
                "color": "${STATUS_COLOR}",
                "title": "${STATUS_EMOJI} Deployment ${{ needs.deploy.result }}",
                "fields": [
                  {
                    "title": "Repository",
                    "value": "${{ github.repository }}",
                    "short": true
                  },
                  {
                    "title": "Branch",
                    "value": "${{ github.ref_name }}",
                    "short": true
                  }
                ]
              }
            ]
          }
          EOF
          )
          
          curl -H "Content-Type: application/json" \
               -X POST \
               -d "${PAYLOAD}" \
               "${{ secrets.SLACK_WEBHOOK_URL }}"

      - name: Update GitHub deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const deployment_id = context.payload.deployment?.id;
            
            if (deployment_id) {
              const state = '${{ needs.deploy.result }}' === 'success' ? 'success' : 'failure';
              
              await github.rest.repos.createDeploymentStatus({
                owner,
                repo,
                deployment_id,
                state,
                description: `Deployment ${state}`,
                environment_url: 'http://${{ env.DEPLOY_HOST || secrets.EC2_HOST }}:3000'
              });
            }
